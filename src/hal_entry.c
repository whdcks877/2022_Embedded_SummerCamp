#include "hal_data.h"
#include <math.h>

#define X1 10
#define X2 45
#define X3 60
#define G 9.8

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
void Num_Selector(void);
void Segment_Write(int seg_data, int seg_digit);
void Segments_Write(int number);
void Segments_Off(void);
void Segment_Clock(int clockOn);
FSP_CPP_FOOTER

extern unsigned char rawData[162880];
int LEDStates[4] = {1,};
int ShootingMode;
int sensor[2] = {0, };

int cnt_en;
int milisec;
int time_1to2;
int EstimatedTime;

int measured;



int offset;

// 0~9: "0~9", 10: "-", 11: blank
const uint8_t SEG[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x27, 0x7F, 0x6F, 0x40, 0x00};
enum opmode {Idle, Dropping, Shooting, Test};

enum opmode OpMode = Idle;
//enum opmode OpMode = Test;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    R_AGT_Open(&g_timer0_ctrl, &g_timer0_cfg);
    R_AGT_Start(&g_timer0_ctrl);

    R_AGT_Open(&g_timer1_ctrl, &g_timer1_cfg);
    R_AGT_Start(&g_timer1_ctrl);

    R_DAC_Open(&g_dac0_ctrl, &g_dac0_cfg);


    R_ICU_ExternalIrqOpen(&g_external_irq8_ctrl, &g_external_irq8_cfg);
    R_ICU_ExternalIrqEnable(&g_external_irq8_ctrl);
    R_ICU_ExternalIrqOpen(&g_external_irq9_ctrl, &g_external_irq9_cfg);
    R_ICU_ExternalIrqEnable(&g_external_irq9_ctrl);
    R_ICU_ExternalIrqOpen(&g_external_irq11_ctrl, &g_external_irq11_cfg);
    R_ICU_ExternalIrqEnable(&g_external_irq11_ctrl);
    R_ICU_ExternalIrqOpen(&g_external_irq12_ctrl, &g_external_irq12_cfg);
    R_ICU_ExternalIrqEnable(&g_external_irq12_ctrl);
    R_ICU_ExternalIrqOpen(&g_external_irq13_ctrl, &g_external_irq13_cfg);
    R_ICU_ExternalIrqEnable(&g_external_irq13_ctrl);

    cnt_en = 0;
    ShootingMode = 0;
    offset = 0;
    milisec = 0;

    measured = 0;
    EstimatedTime = 0;

    uint16_t value;

    R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_09, BSP_IO_LEVEL_HIGH);

    while(1)
    {
        switch(OpMode)
        {
            case Idle:
                //LED1 Blink
                if(LEDStates[1] == 1)
                {
                  R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_09, BSP_IO_LEVEL_LOW);
                }
                else
                {
                  R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_09, BSP_IO_LEVEL_HIGH);
                }
                //Setting LED0
                if(ShootingMode == 0)
                {
                    R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_08, BSP_IO_LEVEL_HIGH);
                }
                else
                {
                    R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_08, BSP_IO_LEVEL_LOW);
                }
                //FND
                Segments_Write(offset);
                break;
            case Dropping:
                Segments_Off();
                if(sensor[0])
                {
                    R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_10, BSP_IO_LEVEL_LOW);
                    cnt_en = 1;
                }
                if(sensor[1])
                {
                    R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_11_PIN_00, BSP_IO_LEVEL_LOW);
                    if(!measured)
                    {
                        EstimatedTime = (int)((sqrt((double)2 / G) * (sqrt(X3) - sqrt(X2))) + time_1to2 + (offset*10) - 1000);
                        //EstimatedTime = ((double)(X3 - X1) / (X2 - X1)) * time_1to2;
                        //EstimatedTime =  time_1to2 * 2;
                        measured = 1;
                    }
                    else
                    {
                        if(milisec >= EstimatedTime)
                        {
                            OpMode = Shooting;
                        }
                    }

                }
                break;
            case Shooting:
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_09_PIN_05, BSP_IO_LEVEL_HIGH);
                R_BSP_SoftwareDelay(300, BSP_DELAY_UNITS_MILLISECONDS);
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_09_PIN_05, BSP_IO_LEVEL_LOW);

                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_10, BSP_IO_LEVEL_HIGH);
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_11_PIN_00, BSP_IO_LEVEL_HIGH);

                cnt_en = 0;
                milisec = 0;
                sensor[0] = 0;
                sensor[1] = 0;
                measured = 0;
                ShootingMode = 0;

                OpMode = Idle;
                R_DAC_Start(&g_dac0_ctrl);
                for(uint32_t i = 0; i < sizeof(rawData); i += 2)
                {
                    value = (uint16_t)(rawData[i] | (rawData[i + 1] << 8));
                    R_DAC_Write(&g_dac0_ctrl, value);
                    R_BSP_SoftwareDelay(22, BSP_DELAY_UNITS_MICROSECONDS);
                }
                R_DAC_Stop(&g_dac0_ctrl);
                break;
            case Test:
                R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_09_PIN_05, BSP_IO_LEVEL_HIGH);
                R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_09_PIN_05, BSP_IO_LEVEL_LOW);

                break;
            default:
                break;
        }
    }
    /* TODO: add your own code here */


#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}


void R_AGT0_Interrupt(timer_callback_args_t *p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);
    if(cnt_en)
    {
        milisec++;
    }
}

void R_AGT1_Interrupt(timer_callback_args_t *p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);
    LEDStates[1] ^= 1;
}

void R_IRQ_Interrupt(external_irq_callback_args_t *p_args)
{
    switch(p_args->channel)
    {
        case 8:
            if(OpMode == Idle && ShootingMode)
            {
                sensor[0] = 1;
                OpMode = Dropping;
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_09, BSP_IO_LEVEL_HIGH);
            }
            break;
        case 9:
            if(sensor[0])
            {
                sensor[1] = 1;
                time_1to2 = milisec;
            }
            break;
        case 11:
            ShootingMode ^= 1;
            break;
        case 12:
            if(OpMode == Idle)
            {
                if(offset >= 999)
                {
                    offset = 999;
                }
                else
                {
                    offset++;
                }
            }
            break;
        case 13:
            if(OpMode == Idle)
            {
                if(offset <= -999)
                {
                    offset = -999;
                }
                else
                {
                    offset--;
                }
            }
            break;
        default:
            break;
    }
}


void Segments_Off()
{
    int digit[4]={11,11,11,11};
    for(int i=0;i<4;i++)
    {
        Segment_Write(SEG[digit[i]], i + 1);
        R_BSP_SoftwareDelay(2, BSP_DELAY_UNITS_MILLISECONDS);
    }
}
void Segments_Write(int number)
{
    int digit[4]={0,0,0,0};
    if(number >=0)
    {
        if(number < 10)
        {
            digit[0] = 11;
            digit[1] = 11;
            digit[2] = 11;
            digit[3] = (number%10);
            for(int i=0;i<4;i++)
            {
                Segment_Write(SEG[digit[i]], i + 1);
                R_BSP_SoftwareDelay(2, BSP_DELAY_UNITS_MILLISECONDS);
            }
        }
        else if(number < 100)
        {
            digit[0] = 11;
            digit[1] = 11;
            digit[2] = (number%100)/10;
            digit[3] = (number%10);
            for(int i=0;i<4;i++)
            {
                Segment_Write(SEG[digit[i]], i + 1);
                R_BSP_SoftwareDelay(2, BSP_DELAY_UNITS_MILLISECONDS);
            }
        }
        else
        {
            digit[0] = 11;
            digit[1] = (number%1000)/100;
            digit[2] = (number%100)/10;
            digit[3] = (number%10);
            for(int i=0;i<4;i++)
            {
                Segment_Write(SEG[digit[i]], i + 1);
                R_BSP_SoftwareDelay(2, BSP_DELAY_UNITS_MILLISECONDS);
            }
        }
    }
    else
    {
        number = number * (-1);
        if(number < 10)
        {
            digit[0] = 11;
            digit[1] = 11;
            digit[2] = 10;
            digit[3] = (number%10);
           for(int i=0;i<4;i++)
           {
               Segment_Write(SEG[digit[i]], i + 1);
               R_BSP_SoftwareDelay(2, BSP_DELAY_UNITS_MILLISECONDS);
           }
        }
        else if(number < 100)
        {
            digit[0] = 11;
            digit[1] = 10;
            digit[2] = (number%100)/10;
            digit[3] = (number%10);
           for(int i=0;i<4;i++)
           {
               Segment_Write(SEG[digit[i]], i + 1);
               R_BSP_SoftwareDelay(2, BSP_DELAY_UNITS_MILLISECONDS);
           }
        }
        else
        {
            digit[0] = 10;
            digit[1] = (number%1000)/100;
            digit[2] = (number%100)/10;
            digit[3] = (number%10);
           for(int i=0;i<4;i++)
           {
               Segment_Write(SEG[digit[i]], i + 1);
               R_BSP_SoftwareDelay(2, BSP_DELAY_UNITS_MILLISECONDS);
           }
        }
    }

    Segment_Clock(0);
}

/*
 * Port 3 : FND_D1~D4(5~8), Col(9) (digit position selector)
 * Port 6 : FND_A~G(4~7, 11~13), Dot(14) (individual digit data)
 */
void Segment_Write(int seg_data, int seg_digit)
{
    if(seg_digit != 0)  {
        /*
         * index :        98|7654|3210
         * Value : 0000|0000|0001|0000 << seg_digit(1~4)
         * Mask  : 0000|0001|1110|0000
         *           0    1    E    0
         */
        R_IOPORT_PortWrite(&g_ioport_ctrl, BSP_IO_PORT_03, (ioport_size_t)(0x0010 << seg_digit), (ioport_size_t)0x01E0); // each digit
        /*         1111 11
         * index : 5432|1098|7654|3210
         * Value : lower 4-bit = pin4~7
         *         upper 4-bit = pin11~14
         * Mask  : 0111|1000|1111|0000
         *           7    8    F    0
         */
        R_IOPORT_PortWrite(&g_ioport_ctrl, BSP_IO_PORT_06, (ioport_size_t)((((~seg_data) & 0x0f) << 4) | (((~seg_data) & 0xf0) << 7)), (ioport_size_t)0x78f0); // data
    }
}

void Segment_Clock(int clockOn)
{
    if(clockOn == 1)
    {
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_03_PIN_09, BSP_IO_LEVEL_HIGH);
    }
    else
    {
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_03_PIN_09, BSP_IO_LEVEL_LOW);
    }

}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
